REPEAT = 1 # How many times to repeat each run
INT_VERSION = false
NUMBER_OF_VERTICES1 = 10
NUMBER_OF_VERTICES2 = 10
EDGE_PROBABILITY = 0.5
EDGE_PROBABILITY_RANGE = 0 0.5 1 # First, increment, last
LABEL_PROBABILITY = 0.3
LABEL_PROBABILITY_RANGE = 0 0.1 1 # First, increment, last
#SIZE_OF_CLIQUE = 5

# A list of filenames for the MiniZinc models. Must be in the same order as targets for each rule. The same name with a
# dzn extension must be generated by the generator
FILENAMES = subgraph.csv clique.csv
CSV_FILE = graphs/db/GREC-GED/GREC-low-level-info/GREC5-lowlevelinfo.csv

define write_header
	for file in $(FILENAMES) ; do \
		echo "edge probability,answer,runtime,solvetime,solutions,variables,propagators,propagations,nodes,failures,restarts,peak depth" \
			> "$${file}" ; \
	done
endef

define convert_results_to_csv
	for file in $(FILENAMES) ; do \
		sed -i 's/=====UNSATISFIABLE=====/-1/g' "$${file}" ; \
		sed -i 's/[a-zA-Z]*\s=\s.*;/1/g' "$${file}" ; \
		sed -i 's/\s----------\(\s==========\)\?//g' "$${file}" ; \
		sed -i 's/\s%%/,/g' "$${file}" ; \
		sed -i 's/[a-z]*:\s[0-9]*\.[0-9]*\s(\([0-9]*\.[0-9]*\)\sms)/\1/g' "$${file}" ; \
		sed -i 's/[a-z]\+\(\s[a-z]*\)\?:\s\([0-9]*\)/\2/g' "$${file}" ; \
	done
endef

define run_models
	models=($^) ; \
	filenames=($(FILENAMES)) ; \
	data_files=($(FILENAMES:.csv=.dzn)) ; \
	for i in "$${!models[@]}" ; do \
		echo "$${edge_probability}," `mzn-gecode -p 9 -s $${models[$$i]} $${data_files[$$i]}` >> "$${filenames[$$i]}" ; \
	done
endef

# Can be used for the decision problem by setting the SIZE_OF_CLIQUE variable and changing the target file
clique: models/Clique.mzn
	$(call write_header)
	for edge_probability in $(shell seq $(EDGE_PROBABILITY_RANGE)) ; do \
		r=1 ; while [[ $$r -le $(REPEAT) ]] ; do \
			python generator.py $@ $(NUMBER_OF_VERTICES1) "$${edge_probability}"$(if $(SIZE_OF_CLIQUE), $(SIZE_OF_CLIQUE),) ; \
			$(call run_models) ; \
			((r = r + 1)) ; \
		done ; \
	done
	$(call convert_results_to_csv)

# Pattern graph has a fixed edge probability, target graph has a range of probabilities
subgraph: models/Subgraph.mzn
	$(call write_header)
	for edge_probability in $(shell seq $(EDGE_PROBABILITY_RANGE)) ; do \
		r=1 ; while [[ $$r -le $(REPEAT) ]] ; do \
			python generator.py $@ $(NUMBER_OF_VERTICES1) $(EDGE_PROBABILITY) $(NUMBER_OF_VERTICES2) "$${edge_probability}"  ; \
			$(call run_models) ; \
			((r = r + 1)) ; \
		done ; \
	done
	$(call convert_results_to_csv)

subgraphClique: models/CommonInducedSubgraph.mzn models/Clique.mzn
	$(call write_header)
	for edge_probability in $(shell seq $(EDGE_PROBABILITY_RANGE)) ; do \
		r=1 ; while [[ $$r -le $(REPEAT) ]] ; do \
			python generator.py $@ $(NUMBER_OF_VERTICES1) $(EDGE_PROBABILITY) $(NUMBER_OF_VERTICES2) "$${edge_probability}"  ; \
			$(call run_models) ; \
			((r = r + 1)) ; \
		done ; \
	done
	$(call convert_results_to_csv)

labelledSubgraph: models/LabelledCommonInducedSubgraph.mzn models/Clique.mzn
	$(call write_header)
	for edge_probability in $(shell seq $(EDGE_PROBABILITY_RANGE)) ; do \
		for label_probability in $(shell seq $(LABEL_PROBABILITY_RANGE)) ; do \
			r=1 ; while [[ $$r -le $(REPEAT) ]] ; do \
				python generator.py $@ $(NUMBER_OF_VERTICES1) $(EDGE_PROBABILITY) $(LABEL_PROBABILITY) \
					$(NUMBER_OF_VERTICES2) "$${edge_probability}" "$${label_probability}" ; \
				$(call run_models) ; \
				((r = r + 1)) ; \
			done ; \
		done ; \
	done
	$(call convert_results_to_csv)

ged: models/GraphEditDistance2.mzn models/MinimumWeightClique2.mzn models/MinimumWeightClique.mzn
	$(call write_header)
	while IFS=";" read name1 name2 nodes1 nodes2 edges1 edges2 method param distance optimal class1 class2 matching ; do \
		models=(cp vertex-weights vertex-edge-weights) ; \
		prefix="graphs/db/GREC-GED/GREC/"
		for i in "$${!models[@]}" ; do \
			filename="graphs/dzn/$${models[$$i]}/GREC/$${name1%.*}-$${name2%.*}.dzn" ; \
			if [ ! -f "$${filename}" ] ; then \
				python convert.py "$${models[$$i]}" dzn "$${prefix}$${name1}" "$${prefix}$${name2}"$(if $(INT_VERSION), int,)
			fi ; \
		done ; \
	done < $(CSV_FILE)
	$(call convert_results_to_csv)
